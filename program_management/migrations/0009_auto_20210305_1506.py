# Generated by Django 2.2.13 on 2021-03-05 15:06
import uuid

from django.db import migrations
from django.db.models import Q

from base.models.education_group_year import EducationGroupYear
from base.models.group_element_year import GroupElementYear
from education_group.models.group_year import GroupYear
from program_management.models.element import Element


def clean_offers_without_version(apps, schema_editor):
    problematic_egys = find_problematic_egys()
    print("Problematic EducationGroupYears: {}".format(len(problematic_egys)))

    delete_offers_before_2019(problematic_egys)
    create_missing_version_and_group_after_2018(problematic_egys)


def create_missing_version_and_group_after_2018(problematic_egys):
    after_2018_egys = problematic_egys.filter(academic_year__year__gt=2018)
    print("Creating {} missing Versions & Groups (after 2018)".format(len(after_2018_egys)))
    for egy in after_2018_egys:
        print("\tCreating {} {}".format(egy.acronym, egy.academic_year.year))
        previous_egy = egy.education_group.educationgroupyear_set.prefetch_related(
            'educationgroupversion_set'
        ).get(academic_year__year=egy.academic_year.year - 1)
        previous_version = previous_egy.educationgroupversion_set.prefetch_related(
            'root_group__element__parent_elements'
        ).get(version_name='', is_transition=False)
        previous_geys = previous_version.root_group.element.parent_elements.all()

        group = _get_or_create_group(egy, previous_version)

        element = _get_or_create_element(group)

        _copy_content_from_previous_year(egy, element, previous_geys)

        _create_version(egy, group, previous_version)


def _get_or_create_element(group):
    element, e_created = Element.objects.get_or_create(
        group_year_id=group.id
    )
    if e_created:
        print("\t\tNew element created")
    return element


def _copy_content_from_previous_year(egy, element, previous_geys):
    for previous_gey in previous_geys:
        new_child = _get_or_create_child(egy, previous_gey)
        child_element, _ = Element.objects.get_or_create(group_year=new_child)

        new_gey, g_created = GroupElementYear.objects.get_or_create(
            parent_element_id=element.pk,
            child_element_id=child_element.pk,
            defaults={
                'relative_credits': previous_gey.relative_credits,
                'min_credits': previous_gey.min_credits,
                'max_credits': previous_gey.max_credits,
                'is_mandatory': previous_gey.is_mandatory,
                'block': previous_gey.block,
                'access_condition': previous_gey.access_condition,
                'comment': previous_gey.comment,
                'comment_english': previous_gey.comment_english,
                'own_comment': previous_gey.own_comment,
                'quadrimester_derogation': previous_gey.quadrimester_derogation,
                'link_type': previous_gey.link_type
            }
        )
        if g_created:
            print("\t\tGroupElementYear (parent={}, child={}) created".format(
                egy.partial_acronym,
                child_element.group_year.partial_acronym
            ))


def _get_or_create_child(egy, previous_gey):
    previous_child = previous_gey.child_element.group_year
    existing_child = GroupYear.objects.filter(
        partial_acronym=previous_child.partial_acronym,
        academic_year=egy.academic_year
    )
    if not existing_child:
        new_child = previous_child
        new_child.pk = None
        new_child.external_id = None
        new_child.academic_year = egy.academic_year
        new_child.uuid = uuid.uuid4()
        new_child.save()

    else:
        new_child = existing_child.first()
    return new_child


def _create_version(egy, group, version):
    version.pk = None
    version.external_id = None
    version.uuid = uuid.uuid4()
    version.root_group = group
    version.offer = egy
    version.save()


def _get_or_create_group(egy, version):
    existing_group = GroupYear.objects.filter(
        academic_year=egy.academic_year,
        partial_acronym=egy.partial_acronym
    )
    if not existing_group:
        print("\t\tCreating new group")
        group = version.root_group
        group.pk = None
        group.external_id = None
        group.uuid = uuid.uuid4()
        group.academic_year = egy.academic_year
        group.save()
    else:
        print("\t\tUsing existing group")
        group = existing_group.first()
    return group


def delete_offers_before_2019(problematic_egys):
    before_2019_egys = problematic_egys.filter(academic_year__year__lt=2019)
    print("Deleting {} EducationGroupYears without version (before 2019) : ".format(len(before_2019_egys)))
    for egy in before_2019_egys:
        print("\tDeleting {} {}".format(egy.acronym, egy.academic_year.year))
        _delete_enrollments(egy)
    before_2019_egys.delete()


def _delete_enrollments(egy):
    offer_enrollments = egy.offerenrollment_set.all()
    if offer_enrollments:
        print("\t\t Deleting {} OfferEnrollments".format(len(offer_enrollments)))
        offer_enrollments.delete()


def find_problematic_egys():
    return EducationGroupYear.objects.filter(
        educationgroupversion__isnull=True
    ).exclude(
        Q(acronym__icontains='11BA') | Q(acronym__icontains='common')
    ).select_related(
        'academic_year'
    ).prefetch_related(
        'offerenrollment_set',
        'education_group__educationgroupyear_set'
    ).order_by('academic_year__year')


class Migration(migrations.Migration):
    dependencies = [
        ('program_management', '0008_auto_20200826_0835'),
    ]

    operations = [
        migrations.RunPython(clean_offers_without_version),
    ]
